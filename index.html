<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Marshall WBCI — Crash Risk Model (Single File)</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@3"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1"></script>
<style>
  :root{
    --bg:#0f1226; --panel:#161a38; --muted:#9aa2c9; --text:#eef0ff;
    --ok:#21d07a; --warn:#ffd166; --risk:#ff5c7a; --accent:#7ea6ff;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:14px system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:16px 14px 8px}
  h1{margin:0 0 6px;font-size:18px}
  .bar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  input,button{font:14px system-ui;border:0;border-radius:8px;padding:10px}
  input{flex:1;background:#1b2148;color:var(--text)}
  button{background:#2c3270;color:#fff;cursor:pointer}
  main{padding:10px}
  .grid{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:900px){.grid{grid-template-columns:2fr 1fr}}
  .card{background:var(--panel);border-radius:12px;padding:12px}
  .kpi{display:flex;gap:12px;flex-wrap:wrap}
  .pill{background:#0f1330;padding:8px 10px;border-radius:999px;color:var(--muted);font-weight:600}
  .pill b{color:var(--text)}
  .score{font-size:40px; font-weight:800}
  .badge{padding:4px 8px;border-radius:12px;font-weight:700}
  .g{background:rgba(31,208,122,.14);color:var(--ok)}
  .y{background:rgba(255,209,102,.18);color:var(--warn)}
  .r{background:rgba(255,92,122,.18);color:var(--risk)}
  .muted{color:var(--muted)}
  .mono{font:12px ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .col{flex:1 1 260px}
  .sub{color:var(--muted);font-size:12px}
  .table{width:100%;border-collapse:collapse}
  .table th,.table td{padding:6px 8px;border-bottom:1px solid #20254d}
  .table th{font-weight:700;color:#cfd6ff;text-align:left}
</style>
</head>
<body>
<header>
  <h1>Marshall WBCI — Crash Risk Model</h1>
  <div class="bar">
    <input id="apiKey" placeholder="Paste your FRED API key (32 chars a–z0–9)" spellcheck="false" autocapitalize="none" autocomplete="off">
    <button onclick="runModel()">Run</button>
    <button onclick="runDiagnostics()">Run Diagnostics</button>
    <button onclick="resetCache()">Reset Cache</button>
  </div>
  <div class="sub" id="fresh">data freshness: —</div>
</header>

<main class="grid">
  <section class="card">
    <div class="row" style="align-items:center;">
      <div class="col">
        <div>Composite Crash Risk</div>
        <div id="score" class="score">—</div>
        <div id="badge" class="badge">—</div>
        <div class="sub" id="asOf">—</div>
      </div>
      <div class="col">
        <div class="kpi">
          <div class="pill">Term (10y–3m): <b id="kpi_term">—</b></div>
          <div class="pill">Credit (BAA–AAA): <b id="kpi_credit">—</b></div>
          <div class="pill">Unemp 6m slope: <b id="kpi_unemp">—</b></div>
          <div class="pill">S&P drawdown: <b id="kpi_dd">—</b></div>
          <div class="pill">NFCI: <b id="kpi_nfci">—</b></div>
        </div>
      </div>
    </div>
    <canvas id="compChart" height="150"></canvas>
  </section>

  <aside class="card">
    <div><b>Executive Summary</b></div>
    <div id="exec" style="margin-top:6px"></div>
    <hr style="border:0;border-top:1px solid #20254d;margin:10px 0">
    <div><b>Diagnostics</b></div>
    <div id="diag" class="mono muted">Ready.</div>
  </aside>

  <section class="card">
    <b>Indicator Charts</b>
    <div class="row">
      <div class="col"><div class="sub">10y–3m (T10Y3M)</div><canvas id="chTerm" height="120"></canvas></div>
      <div class="col"><div class="sub">BAA–AAA spread</div><canvas id="chCredit" height="120"></canvas></div>
      <div class="col"><div class="sub">Unemployment (UNRATE)</div><canvas id="chUnemp" height="120"></canvas></div>
      <div class="col"><div class="sub">S&P 500 (SP500)</div><canvas id="chSPX" height="120"></canvas></div>
      <div class="col"><div class="sub">NFCI</div><canvas id="chNFCI" height="120"></canvas></div>
    </div>
  </section>

  <section class="card">
    <b>Model Weights & Latest</b>
    <table class="table"><thead>
      <tr><th>Indicator</th><th>Series</th><th>Weight</th><th>Latest</th><th>Z-score</th><th>Direction</th></tr>
    </thead><tbody id="weightsBody"></tbody></table>
  </section>
</main>

<script>
/*** ========= Settings ========= ***/
const TTL_MS = 1000*60*60*6; // 6 hours
const CACHE_KEY = 'wbci_cache_v2';
const SERIES = {
  T10Y3M:{id:'T10Y3M',name:'10y–3m Term',freq:'daily'},
  AAA:{id:'AAA',name:'AAA Yield',freq:'daily'},
  BAA:{id:'BAA',name:'BAA Yield',freq:'daily'},
  UNRATE:{id:'UNRATE',name:'Unemployment',freq:'monthly'},
  SP500:{id:'SP500',name:'S&P 500',freq:'daily'},
  NFCI:{id:'NFCI',name:'NFCI',freq:'weekly'}
};
const WEIGHTS = { term:.25, credit:.25, unemp:.15, drawdown:.20, nfci:.15 };
const BANDS = { green:0.5, amber:1.0 };

/*** ========= DOM helpers ========= ***/
const qs = s=>document.querySelector(s);
const set = (sel,txt)=>{ qs(sel).textContent = txt; };
function setBadge(score){
  const b=qs('#badge'); b.className='badge';
  if(score<=BANDS.green){ b.textContent='GREEN'; b.classList.add('g'); }
  else if(score<=BANDS.amber){ b.textContent='AMBER'; b.classList.add('y'); }
  else { b.textContent='RED'; b.classList.add('r'); }
}
function setDiag(msg, cls){ const el=qs('#diag'); el.textContent=msg; el.className='mono '+(cls||'muted'); }
const fmt = (x,d=2)=>Number.isFinite(x)?x.toFixed(d):'—';
const fmtPct = (x,d=1)=>Number.isFinite(x)?(x*100).toFixed(d)+'%':'—';
function last(arr){ return arr[arr.length-1]; }
function daysBetween(a,b){ return Math.abs((+a-+b)/86400000); }

/*** ========= Storage ========= ***/
function saveCache(obj){ localStorage.setItem(CACHE_KEY, JSON.stringify({t:Date.now(),obj})); }
function loadCache(){ try{ const j=localStorage.getItem(CACHE_KEY); if(!j) return null; const o=JSON.parse(j); if(Date.now()-o.t<TTL_MS) return o.obj; }catch{} return null; }
function resetCache(){ localStorage.removeItem(CACHE_KEY); setDiag('Cache cleared.'); }

/*** ========= FRED ========= ***/
async function fredObs(seriesId, key, start){
  const url = `https://api.stlouisfed.org/fred/series/observations?series_id=${seriesId}&file_type=json&api_key=${key}` + (start?`&observation_start=${start}`:'');
  const res = await fetch(url, {cache:'no-store'});
  if(!res.ok){ throw new Error(`HTTP ${res.status} ${seriesId}: ${await res.text()}`); }
  const j = await res.json();
  if(j.error_code){ throw new Error(`${seriesId} FRED ${j.error_code}: ${j.error_message}`); }
  const arr = j.observations.map(o=>({t:o.date, v:parseFloat(o.value)})).filter(p=>!isNaN(p.v));
  return {series:seriesId, data:arr, lastDate:last(j.observations)?.date};
}

/*** ========= Stats / transforms ========= ***/
function rollingStats(vals, window){
  if(vals.length<window) window = Math.max(30, Math.floor(vals.length*0.6));
  const sub = vals.slice(-window);
  const mean = sub.reduce((a,b)=>a+b,0)/sub.length;
  const sd = Math.sqrt(sub.reduce((a,b)=>a+(b-mean)**2,0)/(sub.length-1)) || 1e-9;
  return {mean, sd};
}
function slope(vals, n){ if(vals.length<n+1) return 0; return (vals[vals.length-1] - vals[vals.length-1-n]) / n; }
function joinCredit(baa, aaa){
  const m=new Map(aaa.map(p=>[p.t,p.v])); const out=[];
  for(const p of baa){ if(m.has(p.t)) out.push({t:p.t, v:p.v - m.get(p.t)}); }
  return out;
}
function drawdownSeries(spx, lb=252){
  const out=[]; let max=-Infinity; const buf=[];
  for(const p of spx){
    buf.push(p.v); if(buf.length>lb) buf.shift();
    max = Math.max(...buf);
    const dd = (p.v - max)/max; out.push({t:p.t, v:dd}); // <=0
  }
  return out;
}
function mapSeries(arr){ const m=new Map(); for(const p of arr){ m.set(p.t, p.v); } return m; }
function forwardFillGet(mapArr, keys){
  // mapArr: array of {t, v} sorted by time; keys: target dates asc
  const out=[]; let j=0;
  for(let i=0;i<keys.length;i++){
    const k=keys[i];
    while(j+1<mapArr.length && mapArr[j+1].t<=k) j++;
    out.push({t:k, v: mapArr[Math.min(j,mapArr.length-1)].v});
  }
  return out;
}

/*** ========= Model ========= ***/
async function runModel(){
  setDiag('Running…');
  const key = qs('#apiKey').value.trim();
  if(!/^[a-z0-9]{32}$/.test(key)){ setDiag('Invalid API key. Must be exactly 32 chars a–z0–9.', 'r'); return; }

  const cached = loadCache();
  if(cached && cached.key===key){ render(cached.payload, true); setDiag('Loaded from cache.'); return; }

  try{
    const start='2010-01-01';
    const [sTerm, sAAA, sBAA, sU, sSPX, sNFCI] = await Promise.all([
      fredObs(SERIES.T10Y3M.id, key, start),
      fredObs(SERIES.AAA.id, key, start),
      fredObs(SERIES.BAA.id, key, start),
      fredObs(SERIES.UNRATE.id, key, start),
      fredObs(SERIES.SP500.id, key, start),
      fredObs(SERIES.NFCI.id, key, start)
    ]);

    // Derived
    const credit = joinCredit(sBAA.data, sAAA.data);           // daily
    const dd = drawdownSeries(sSPX.data, 252);                 // daily
    const unVals = sU.data.map(p=>p.v);
    const unSlope6 = slope(unVals, 6);                         // latest slope (pp over 6m)

    // Baseline stats for z-scores (approx 10y windows)
    const zTermBase = rollingStats(sTerm.data.map(p=>p.v), 2520);
    const zCreditBase = rollingStats(credit.map(p=>p.v), 2520);
    const zDDBase = rollingStats(dd.map(p=>p.v), 2520);
    const zNFCIBase = rollingStats(sNFCI.data.map(p=>p.v), 520);

    // Build historical monthly slopes for UNRATE to z-score the latest slope
    const unSlopes = [];
    for(let i=6;i<unVals.length;i++){ unSlopes.push((unVals[i]-unVals[i-6])/6); }
    const zUnBase = rollingStats(unSlopes, 120);
    const zTerm = (last(sTerm.data).v - zTermBase.mean)/zTermBase.sd;
    const zCredit = (last(credit).v - zCreditBase.mean)/zCreditBase.sd;
    const zDD = (last(dd).v - zDDBase.mean)/zDDBase.sd;
    const zNFCI = (last(sNFCI.data).v - zNFCIBase.mean)/zNFCIBase.sd;
    const zUn = (unSlope6 - zUnBase.mean)/zUnBase.sd;

    // Components (positive = more risk)
    const compTerm = -zTerm * WEIGHTS.term;     // positive term spread = safer → invert
    const compCred = +zCredit * WEIGHTS.credit; // wider credit = risk
    const compUn   = +zUn * WEIGHTS.unemp;      // rising unemployment = risk
    const compDD   = -zDD * WEIGHTS.drawdown;   // deeper dd (more negative) → risk
    const compNFCI = +zNFCI * WEIGHTS.nfci;     // tighter conditions = risk

    const composite = compTerm + compCred + compUn + compDD + compNFCI;

    // Composite timeline (last ~250 trading days) using fixed baselines above
    const dates = sSPX.data.slice(-260).map(p=>p.t);
    const termFF = forwardFillGet(sTerm.data, dates).map(x=>({t:x.t, z:(x.v - zTermBase.mean)/zTermBase.sd}));
    const credFF = forwardFillGet(credit, dates).map(x=>({t:x.t, z:(x.v - zCreditBase.mean)/zCreditBase.sd}));
    const ddFF   = forwardFillGet(dd, dates).map(x=>({t:x.t, z:(x.v - zDDBase.mean)/zDDBase.sd}));
    const nfFF   = forwardFillGet(sNFCI.data, dates).map(x=>({t:x.t, z:(x.v - zNFCIBase.mean)/zNFCIBase.sd}));
    // Monthly unemp slope → forward-fill to dates
    const unSlopeSeries = [];
    for(let i=6;i<sU.data.length;i++){
      unSlopeSeries.push({t:sU.data[i].t, v:(sU.data[i].v - sU.data[i-6].v)/6});
    }
    const unFF = forwardFillGet(unSlopeSeries, dates).map(x=>({t:x.t, z:(x.v - zUnBase.mean)/zUnBase.sd}));

    const compHist = dates.map((d,i)=>({
      x:d,
      y: (-termFF[i].z)*WEIGHTS.term + (credFF[i].z)*WEIGHTS.credit + (unFF[i].z)*WEIGHTS.unemp + (-ddFF[i].z)*WEIGHTS.drawdown + (nfFF[i].z)*WEIGHTS.nfci
    }));

    const payload = {
      series:{term:sTerm, aaa:sAAA, baa:sBAA, credit, un:sU, spx:sSPX, dd, nfci:sNFCI, compHist},
      zs:{zTerm,zCredit,zUn,zDD,zNFCI},
      comps:{compTerm,compCred,compUn,compDD,compNFCI},
      composite,
      meta:{T10Y3M:sTerm.lastDate, AAA:sAAA.lastDate, BAA:sBAA.lastDate, UNRATE:sU.lastDate, SP500:sSPX.lastDate, NFCI:sNFCI.lastDate},
      key
    };

    saveCache({key, payload});
    render(payload, false);
    setDiag('✅ Loaded fresh from FRED.','g');

  }catch(e){
    setDiag('❌ '+e.message,'r');
  }
}

function render(p, fromCache){
  // KPIs (latest)
  const term = last(p.series.term.data).v;
  const credit = last(p.series.credit).v;
  const unSlope6 = (()=>{
    const u=p.series.un.data.map(x=>x.v); return slope(u,6);
  })();
  const dd = last(p.series.dd).v;
  const nf=p.series.nfci.data[p.series.nfci.data.length-1].v;

  set('#kpi_term', fmt(term,2));
  set('#kpi_credit', fmt(credit,2)+' pts');
  set('#kpi_unemp', fmt(unSlope6,2)+' pp/6m');
  set('#kpi_dd', fmtPct(dd,1));
  set('#kpi_nfci', fmt(nf,3));

  // Score & status
  set('#score', fmt(p.composite,2));
  setBadge(p.composite);
  set('#asOf', `as of: T10Y3M ${p.meta.T10Y3M} • AAA ${p.meta.AAA} • BAA ${p.meta.BAA} • UNRATE ${p.meta.UNRATE} • SP500 ${p.meta.SP500} • NFCI ${p.meta.NFCI}`);
  set('#fresh', freshness(p.meta));

  // Exec summary
  qs('#exec').innerHTML = summaryText(p);

  // Charts
  drawLine('#chTerm', p.series.term.data, 'T10Y3M');
  drawLine('#chCredit', p.series.credit, 'BAA–AAA');
  drawLine('#chUnemp', p.series.un.data, 'UNRATE');
  drawLine('#chSPX', p.series.spx.data, 'SP500');
  drawLine('#chNFCI', p.series.nfci.data, 'NFCI');
  drawLine('#compChart', p.series.compHist, 'Composite (z-weighted)');

  // Weights table
  const tb=qs('#weightsBody'); tb.innerHTML='';
  const rows=[
    ['Term spread','T10Y3M',WEIGHTS.term, term, p.zs.zTerm, 'Higher safer → inverted'],
    ['Credit spread','BAA-AAA',WEIGHTS.credit, credit, p.zs.zCredit, 'Wider = risk'],
    ['Unemployment slope (6m)','UNRATE',WEIGHTS.unemp, unSlope6, p.zs.zUn, 'Rising = risk'],
    ['Equity drawdown (12m)','SP500',WEIGHTS.drawdown, dd, p.zs.zDD, 'More negative = risk'],
    ['NFCI','NFCI',WEIGHTS.nfci, nf, p.zs.zNFCI, 'Higher = tighter = risk']
  ];
  for(const r of rows){
    const tr=document.createElement('tr');
    tr.innerHTML = `<td>${r[0]}</td><td>${r[1]}</td><td>${fmt(r[2],2)}</td><td>${fmt(r[3],3)}</td><td>${fmt(r[4],2)}</td><td>${r[5]}</td>`;
    tb.appendChild(tr);
  }

  if(fromCache) setDiag('Showing cached model. Paste your key and Run for fresh.');
}

/*** ========= Freshness ========= ***/
function freshness(meta){
  const now=new Date(); const flags=[];
  const chk=(name,date,limitDays)=>{
    if(!date){ flags.push(`${name} missing`); return; }
    const age=daysBetween(now,new Date(date));
    if(age>limitDays) flags.push(`${name} stale (${Math.round(age)}d)`);
  };
  chk('T10Y3M', meta.T10Y3M, 7);
  chk('AAA', meta.AAA, 7);
  chk('BAA', meta.BAA, 7);
  chk('UNRATE', meta.UNRATE, 45);
  chk('SP500', meta.SP500, 7);
  chk('NFCI', meta.NFCI, 14);
  return flags.length?('⚠ '+flags.join(' • ')):'All inputs fresh.';
}

/*** ========= Chart ========= ***/
const charts={};
function drawLine(sel, arr, label){
  const ctx=qs(sel).getContext('2d');
  if(charts[sel]) charts[sel].destroy();
  charts[sel]=new Chart(ctx,{
    type:'line',
    data:{datasets:[{label, data:arr.map(p=>({x:p.t,y:p.v}))}]},
    options:{
      responsive:true, parsing:false, normalized:true,
      elements:{point:{radius:0}},
      scales:{x:{type:'time', time:{tooltipFormat:'yyyy-LL-dd'}}}
    }
  });
}

/*** ========= Summary ========= ***/
function summaryText(p){
  const badge = (p.composite<=BANDS.green)?'GREEN':(p.composite<=BANDS.amber?'AMBER':'RED');
  const tone = (badge==='GREEN')?'Low near-term crash risk; conditions broadly supportive.'
             :(badge==='AMBER')?'Mixed signals; monitor credit and macro closely.'
             :'Elevated risk; multiple stress lines aligning.';
  const term = last(p.series.term.data).v;
  const credit = last(p.series.credit).v;
  const dd = last(p.series.dd).v;
  const unSlope6 = (()=>{
    const u=p.series.un.data.map(x=>x.v); return slope(u,6);
  })();
  const nf = last(p.series.nfci.data).v;
  const bullets = [
    (term<0?'Yield curve inverted (10y–3m < 0).':'Yield curve positive.'),
    `Credit spread (BAA–AAA): ${fmt(credit,2)} pts.`,
    `Unemployment 6-month slope: ${fmt(unSlope6,2)} pp/6m ${unSlope6>0?'(rising)':'(flat/falling)'}.`,
    `Equity drawdown from 12-m high: ${fmtPct(dd,1)}.`,
    `NFCI: ${fmt(nf,3)} (${nf>0?'tighter':'looser'} than average).`
  ].map(x=>`<li>${x}</li>`).join('');
  return `<p><span class="badge ${badge==='GREEN'?'g':badge==='AMBER'?'y':'r'}">${badge}</span> &nbsp;Composite = <b>${fmt(p.composite,2)}</b>. ${tone}</p><ul>${bullets}</ul><p class="sub">Educational; not investment advice.</p>`;
}

/*** ========= Diagnostics ========= ***/
async function runDiagnostics(){
  setDiag('Running diagnostics…');
  const key = qs('#apiKey').value.trim();
  if(!/^[a-z0-9]{32}$/.test(key)){ setDiag('Invalid API key. Must be exactly 32 chars a–z0–9.', 'r'); return; }

  // 1) Simple metadata ping
  const metaURL = `https://api.stlouisfed.org/fred/series?series_id=GDP&file_type=json&api_key=${key}`;
  // 2) Typical observations call
  const obsURL = `https://api.stlouisfed.org/fred/series/observations?series_id=SP500&file_type=json&api_key=${key}&observation_start=2014-01-01`;

  try{
    const r1 = await fetch(metaURL,{cache:'no-store'}); const t1 = await r1.text();
    const r2 = await fetch(obsURL,{cache:'no-store'});  const t2 = await r2.text();
    setDiag(
`Ping FRED:
[1] ${metaURL}
HTTP ${r1.status}
${t1.slice(0,300)}

[2] ${obsURL}
HTTP ${r2.status}
${t2.slice(0,300)}
`, (r1.ok&&r2.ok)?'g':'y');
  }catch(e){
    setDiag('Diagnostics error: '+e.message,'r');
  }
}

/*** ========= Init ========= ***/
(() => {
  const c = loadCache();
  if(c){ render(c.payload, true); }
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Marshall WBCI — World’s Best Crash Indicator</title>
<meta name="color-scheme" content="dark light" />
<style>
  :root{
    --bg:#0c0f12; --panel:#12161c; --soft:#1a212b; --muted:#8ca0b3; --text:#e7eef7;
    --green:#32c28f; --amber:#ffb646; --red:#ff5e57; --blue:#52a7ff; --cyan:#49d2e6; --purple:#b084f5;
    --chip:#202836; --danger:#2a0e12; --dangerText:#ff9aa3; --ok:#12301f; --okText:#a2f5c8;
    --focus:#9fd1ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    background:var(--bg); color:var(--text);
  }
  a{color:var(--blue)}
  .app{max-width:1100px; margin:0 auto; padding:16px}
  header{
    background:var(--panel); border-radius:12px; padding:12px; display:grid; gap:12px;
  }
  .topbar{display:grid; grid-template-columns:1fr; gap:8px}
  @media(min-width:720px){ .topbar{grid-template-columns: 1.4fr .9fr .7fr .7fr 1fr} }
  label{display:flex; flex-direction:column; gap:6px; font-size:12px; color:var(--muted)}
  input, select, button{
    background:#0f1318; color:var(--text); border:1px solid #2b3647; border-radius:8px; padding:10px 12px;
  }
  input::placeholder{color:#6b7e92}
  button{
    cursor:pointer; font-weight:600; letter-spacing:.2px;
    background:linear-gradient(180deg, #1b2635, #101722);
  }
  button:hover{filter:brightness(1.05)}
  button:disabled{opacity:.6; cursor:not-allowed}
  :focus-visible{outline:2px solid var(--focus); outline-offset:2px}
  .status{align-self:end; padding:10px 12px; background:var(--soft); border-radius:8px; text-align:center}
  .banner{margin-top:8px; padding:10px 12px; border-radius:10px; background:var(--danger); color:var(--dangerText); border:1px solid #612b31}
  .row{display:grid; gap:12px; margin-top:12px}
  @media(min-width:900px){ .row{grid-template-columns: 360px 1fr} }
  .card{background:var(--panel); border-radius:12px; padding:12px}
  .flex{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .chips{display:flex; gap:8px; flex-wrap:wrap}
  .chip{background:var(--chip); border:1px solid #2a3546; color:#cfe3ff; padding:6px 10px; border-radius:999px; font-size:12px}
  .chip.bad{background:var(--danger); color:var(--dangerText); border-color:#7a2932}
  .chip.good{background:var(--ok); color:var(--okText); border-color:#2f5a48}
  .gaugeWrap{position:relative; display:grid; place-items:center}
  .gaugeNum{position:absolute; text-align:center}
  .gaugeNum .value{font-size:42px; font-weight:800}
  .gaugeNum .band{font-size:12px; letter-spacing:.4px; text-transform:uppercase; color:var(--muted)}
  .diag{margin-top:8px; font-size:12px; color:#ffd0d4}
  .diag ul{margin:6px 0 0 16px}
  .summary{font-size:14px; color:#dae6f5}
  .grid{display:grid; gap:12px}
  .grid.cards{grid-template-columns:1fr}
  @media(min-width:620px){ .grid.cards{grid-template-columns:1fr 1fr} }
  @media(min-width:980px){ .grid.cards{grid-template-columns:1fr 1fr 1fr} }
  .catCard .title{display:flex; justify-content:space-between; align-items:center; margin-bottom:6px}
  .badge{padding:4px 8px; border-radius:999px; font-weight:700; font-size:12px; border:1px solid #2a3546}
  .badge.green{background:#10271f; color:#a7f1ce; border-color:#294a3d}
  .badge.amber{background:#2a220f; color:#ffd9a1; border-color:#5b4a25}
  .badge.red{background:#2a1414; color:#ffb6b0; border-color:#6b2c2a}
  .spark{height:80px}
  .meta{font-size:12px; color:var(--muted); margin-top:6px}
  .context{margin-top:6px}
  .foot{margin-top:18px; font-size:12px; color:#9bb0c6}
  canvas{user-select:none}
  .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}
</style>
</head>
<body>
<div class="app" id="app">
  <header>
    <div class="topbar">
      <label>FRED API Key
        <input id="apiKey" autocomplete="off" spellcheck="false" placeholder="Paste your FRED API key" value="YOUR_FRED_API_KEY_HERE" />
      </label>
      <label>Mode
        <select id="mode">
          <option value="advanced">Advanced (weighted)</option>
          <option value="equal">Equal (all categories = 1.0)</option>
        </select>
      </label>
      <label>Run / Refresh
        <button id="runBtn" title="Fetch from FRED (uses cache when fresh)">Run WBCI</button>
      </label>
      <label>Reset Cache
        <button id="resetBtn" title="Clear only WBCI_* localStorage keys">Reset Cache</button>
      </label>
      <div class="status" id="status">Ready</div>
    </div>
    <div id="apiBanner" class="banner" style="display:none"></div>
  </header>

  <div class="row">
    <section class="card">
      <h2 style="margin:0 0 8px">WBCI Composite</h2>
      <div class="flex" style="gap:12px">
        <div class="gaugeWrap" style="width:240px; height:240px">
          <canvas id="gauge" width="240" height="240" aria-label="WBCI gauge"></canvas>
          <div class="gaugeNum">
            <div class="value" id="wbciVal">—</div>
            <div class="band" id="wbciBand">—</div>
            <div class="meta" id="ts">—</div>
          </div>
        </div>
        <div style="flex:1; min-width:220px">
          <div class="chips" id="chips">
            <div class="chip" id="chipBand">Band: —</div>
            <div class="chip" id="chipBreadth">Breadth: —</div>
            <div class="chip" id="chipSynch">Synchronicity: —</div>
            <div class="chip" id="chipShock">Shock: —</div>
          </div>
          <div class="diag" id="diag" style="display:none">
            <strong>Diagnostics:</strong>
            <ul id="diagList"></ul>
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <h2 style="margin:0 0 8px">Executive Summary</h2>
      <div id="summary" class="summary">Run WBCI to generate today’s CIO-grade summary.</div>
      <div class="foot">Bands: <span class="badge green">0–39 Green</span> <span class="badge amber">40–69 Amber</span> <span class="badge red">70–100 Red</span>. Scores are percentiles vs each series’ last-10y history (after transforms); higher = more crash risk.</div>
    </section>
  </div>

  <section class="grid cards" id="cards" aria-label="Category cards"></section>

  <footer class="foot" style="margin-top:24px">
    Data: Federal Reserve Bank of St. Louis (FRED). App caches raw series for 6 hours (localStorage keys: <code>WBCI_*</code>). No background sync, no randomness. One-click reset clears only those keys.
  </footer>
</div>

<!-- Chart.js (only external dependency) -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js" integrity="sha384-hj4dTqA3mPG0G2sM7jB2qj+pe3c4uQdOCLkU0k0c67+Jf3bqQ3g3RXxqYwHqA8uK" crossorigin="anonymous"></script>

<script>
(function(){
'use strict';

/*** ---------- Config ---------- ***/
const SIX_HOURS = 1000*60*60*6;
const CONCURRENCY_LIMIT = 3; // polite to FRED
const DEFAULT_BANNER_GUIDE = 'Add a valid FRED API key and click “Run WBCI”. Get a key free at fred.stlouisfed.org → My Account → API Keys.';

const CATS = [
  { key:'rates',  name:'Rates / Curve',          weight:1.3, baseline:'Amber: tight curves + high long rates tend to precede slowdowns.', series:[
      {id:'DGS10'}, {id:'T10Y2Y', invert:true}, {id:'T10Y3M', invert:true}
  ]},
  { key:'credit', name:'Credit / Stress',        weight:1.3, baseline:'Amber: wider HY spreads & stress indices signal fragility.', series:[
      {id:'BAMLH0A0HYM2'}, {id:'STLFSI4'}
  ]},
  { key:'liquidity', name:'Liquidity',           weight:1.0, baseline:'Amber: tight liquidity amplifies shocks; ample liquidity cushions.', series:[
      {id:'RRPONTSYD', scale:1e-3}, {id:'WALCL', scale:1e-3, invert:true}
  ]},
  { key:'usd',    name:'USD / External',         weight:1.1, baseline:'Amber: a strong dollar pressures trade and EM funding.', series:[
      {id:'DTWEXBGS'}
  ]},
  { key:'energy', name:'Energy Shock',           weight:1.0, baseline:'Amber: fast oil price jumps tax consumers and squeeze margins.', series:[
      {id:'DCOILWTICO', transform:'yoy'}
  ]},
  { key:'labor',  name:'Labor / Household',      weight:1.1, baseline:'Amber: rising unemployment or claims often mark late‑cycle.', series:[
      {id:'UNRATE'}, {id:'ICSA', scale:1e-3}
  ]},
  { key:'activity', name:'Activity / Sentiment', weight:1.0, baseline:'Amber: fading growth & confidence reduces risk‑taking.', series:[
      {id:'INDPRO', transform:'yoy', invert:true}, {id:'RSAFS', transform:'yoy', invert:true}, {id:'UMCSENT', invert:true}
  ]}
];

const SERIES_SET = CATS.flatMap(c=>c.series.map(s=>({cat:c.key, ...s})));
const CAT_MAP = Object.fromEntries(CATS.map(c=>[c.key,c]));

/*** ---------- Utilities ---------- ***/
const el = id => document.getElementById(id);
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const mean = arr => arr.length? arr.reduce((a,b)=>a+b,0)/arr.length : NaN;
const std = arr => {
  if(arr.length<2) return 0;
  const m = mean(arr);
  const v = arr.reduce((s,x)=>s+(x-m)*(x-m),0)/(arr.length-1);
  return Math.sqrt(v);
};
const percentileRank = (value, sample, invert=false) => {
  const xs = sample.filter(v=>Number.isFinite(v)).slice().sort((a,b)=>a-b);
  if(!xs.length || !Number.isFinite(value)) return NaN;
  // rank <= value (inclusive) → 0..1
  let lo=0, hi=xs.length;
  while(lo<hi){ const mid=(lo+hi>>1); if(xs[mid]<=value) lo=mid+1; else hi=mid; }
  const p = xs.length? (lo/xs.length) : 0.5;
  const pct = p*100;
  return invert? 100-pct : pct;
};
const monthKey = d => `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}`;
const addMonths = (d,n)=>{ const dt=new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth()+n, 1)); return dt; };
const endOfMonth = (y,m)=> new Date(Date.UTC(y,m+1,0,23,59,59,999));

/*** ---------- Cache helpers ---------- ***/
const cacheKey = (id, start) => `WBCI_SERIES_${id}_${start}`;
const getCache = (key) => {
  try{
    const raw = localStorage.getItem(key);
    if(!raw) return null;
    const obj = JSON.parse(raw);
    if(!obj || !obj.fetchedAt || !obj.data) return null;
    if(Date.now() - obj.fetchedAt > SIX_HOURS) return null;
    return obj.data;
  }catch(e){ return null; }
};
const setCache = (key, data) => {
  try{ localStorage.setItem(key, JSON.stringify({fetchedAt:Date.now(), data})); }catch(e){}
};
const resetCache = ()=>{
  const keys = Object.keys(localStorage);
  keys.forEach(k=>{ if(k.startsWith('WBCI_')) localStorage.removeItem(k); });
};

/*** ---------- Fetch layer (with diagnostics & concurrency) ---------- ***/
async function fetchSeries(id, apiKey, startISO){
  const key = cacheKey(id, startISO);
  const cached = getCache(key);
  if(cached) return { ok:true, id, cached:true, data:cached };

  const url = new URL('https://api.stlouisfed.org/fred/series/observations');
  url.searchParams.set('series_id', id);
  url.searchParams.set('api_key', apiKey);
  url.searchParams.set('file_type', 'json');
  url.searchParams.set('observation_start', startISO);
  // no end param → through latest
  try{
    const res = await fetch(url.toString(), { keepalive:false, cache:'no-store' });
    if(!res.ok){
      return { ok:false, id, reason:`HTTP ${res.status}` };
    }
    const json = await res.json();
    if(json && json.error_code){
      return { ok:false, id, reason:`FRED error ${json.error_code}: ${json.error_message||'Unknown'}` };
    }
    if(!json || !Array.isArray(json.observations) || json.observations.length===0){
      return { ok:false, id, reason:'Empty observations' };
    }
    setCache(key, json);
    return { ok:true, id, cached:false, data:json };
  }catch(err){
    return { ok:false, id, reason:`Fetch error: ${err.message||err}` };
  }
}

async function fetchAllSeries(apiKey, startISO, reportDiag){
  const q = SERIES_SET.map(s=>s.id);
  const diagnostics = [];
  const results = new Map();

  let i=0;
  async function worker(){
    while(i<q.length){
      const id = q[i++]; // simple round-robin
      const r = await fetchSeries(id, apiKey, startISO);
      if(!r.ok){ diagnostics.push(`${id}: ${r.reason}`); }
      else{ results.set(id, r.data); }
      reportDiag(diagnostics.slice());
    }
  }
  const workers = Array.from({length:Math.min(CONCURRENCY_LIMIT,q.length)}, worker);
  await Promise.all(workers);
  return { results, diagnostics };
}

/*** ---------- Transformation & Monthly resampling ---------- ***/
function toMonthlyLast(observations){
  // Map YYYY-MM => last numeric value in that month
  const byMonth = new Map();
  for(const o of observations){
    const v = parseFloat(o.value);
    if(!Number.isFinite(v)) continue;
    const d = new Date(o.date); // FRED ISO
    const mk = monthKey(d);
    const cur = byMonth.get(mk);
    if(!cur || new Date(cur.date) <= d) byMonth.set(mk, {date:o.date, value:v});
  }
  // Return sorted arrays
  const entries = Array.from(byMonth.entries()).sort((a,b)=>a[0]<b[0]?-1:1)
        .map(([mk, obj]) => ({ month: mk, value: obj.value }));
  return entries;
}

function alignMonths(allMonths){
  const sorted = Array.from(new Set(allMonths)).sort();
  const idx = new Map(sorted.map((m,i)=>[m,i]));
  return { months: sorted, indexOf:(m)=>idx.get(m) ?? -1 };
}

function seriesMonthlyTransformed(seriesDef, fredJson){
  // Convert observations to monthly last, then apply transforms (e.g., yoy)
  const rows = toMonthlyLast(fredJson.observations);
  const months = rows.map(r=>r.month);
  let values = rows.map(r=>r.value);

  // optional scaling (doesn't affect percentile but keeps determinism if later used)
  if(seriesDef.scale){ values = values.map(v=>v*seriesDef.scale); }

  if(seriesDef.transform==='yoy'){
    const map = new Map(months.map((m,i)=>[m, values[i]]));
    const yoyMonths = [];
    const yoyValues = [];
    for(const m of months){
      const [y, mo] = m.split('-').map(Number);
      const prev = `${y-1}-${String(mo).padStart(2,'0')}`;
      const v = map.get(m);
      const p = map.get(prev);
      if(Number.isFinite(v) && Number.isFinite(p) && p!==0){
        yoyMonths.push(m);
        yoyValues.push(100*((v/p)-1));
      }
    }
    return { months:yoyMonths, values:yoyValues };
  }
  return { months, values };
}

/*** ---------- Scoring engine ---------- ***/
function computeCategoryAndComposite(allSeriesData){
  // Build unified month axis over last 10y (post-transform)
  const seriesTrans = SERIES_SET.map(s=>{
    const fred = allSeriesData.get(s.id);
    if(!fred) return null;
    return { s, ...seriesMonthlyTransformed(s, fred) };
  }).filter(Boolean);

  const allMonths = new Set(seriesTrans.flatMap(x=>x.months));
  const { months } = alignMonths(allMonths);

  // Restrict to last 10y window from latest month we have
  if(months.length===0) return { months:[], categories:[], composite:[] };
  const lastMonth = months[months.length-1];
  const [ly, lm] = lastMonth.split('-').map(Number);
  const startCut = `${ly-10}-${String(lm).padStart(2,'0')}`;
  const months10y = months.filter(m=>m>=startCut);

  // For each series, build its 10y sample for percentile reference
  const seriesRefSamples = new Map();
  for(const t of seriesTrans){
    const sample = t.months.reduce((acc,m,i)=>{
      if(m>=startCut && Number.isFinite(t.values[i])) acc.push(t.values[i]);
      return acc;
    }, []);
    seriesRefSamples.set(t.s.id, sample);
  }

  // For each month, compute per-series percentile (0..100, high=bad, apply invert flag)
  const perMonthSeriesPct = new Map(); // month -> Map(seriesId -> pct)
  for(const m of months10y){
    const mMap = new Map();
    for(const t of seriesTrans){
      const i = t.months.indexOf(m);
      const v = i>=0 ? t.values[i] : NaN;
      const sample = seriesRefSamples.get(t.s.id) || [];
      const pct = Number.isFinite(v) && sample.length>5
        ? percentileRank(v, sample, !!t.s.invert)
        : NaN;
      if(Number.isFinite(pct)) mMap.set(t.s.id, pct);
    }
    perMonthSeriesPct.set(m, mMap);
  }

  // Category scores per month (average of available series percentiles)
  const categories = CATS.map(c=>({ key:c.key, name:c.name, weight:c.weight, baseline:c.baseline, months:[], scores:[] }));
  for(const m of months10y){
    const map = perMonthSeriesPct.get(m) || new Map();
    for(const cat of categories){
      const seriesIds = CAT_MAP[cat.key].series.map(s=>s.id);
      const vals = seriesIds.map(id=>map.get(id)).filter(v=>Number.isFinite(v));
      const sc = vals.length? mean(vals) : NaN;
      cat.months.push(m);
      cat.scores.push(Number.isFinite(sc)? sc : NaN);
    }
  }

  // Composite per month
  function wbciAt(mIndex, weightsMode){
    let num=0, den=0;
    for(const cat of categories){
      const v = cat.scores[mIndex];
      if(Number.isFinite(v)){
        const w = weightsMode==='equal'? 1.0 : CAT_MAP[cat.key].weight;
        num += v * w; den += w;
      }
    }
    return den>0? num/den : NaN;
  }
  const composite = months10y.map((_,i)=> wbciAt(i, el('mode').value||'advanced') );

  return { months: months10y, categories, composite, perMonthSeriesPct, seriesTrans };
}

/*** ---------- Synchronicity & Shock ---------- ***/
// Synchronicity: 1 − stddev(category z-scores) normalized 0–100
function computeSynchronicity(categories, curIndex){
  const zs = [];
  for(const cat of categories){
    const xs = cat.scores.filter(Number.isFinite);
    if(xs.length<6) continue;
    const mu = mean(xs), sd = std(xs);
    const v = cat.scores[curIndex];
    if(Number.isFinite(v)){
      const z = sd>0 ? (v - mu)/sd : 0;
      zs.push(z);
    }
  }
  if(zs.length<2) return NaN;
  const dispersion = std(zs);              // typical 0.5–2.5
  const NORM_MAX = 2.5;                    // normalization cap (assumption)
  const syn = 100*(1 - clamp(dispersion/NORM_MAX, 0, 1));
  return syn;
}

// Shock: percentile of absolute 1‑month change in WBCI using last 24m history
function computeShock(months, composite){
  const pairs = [];
  for(let i=1;i<composite.length;i++){
    const a = composite[i-1], b = composite[i];
    if(Number.isFinite(a) && Number.isFinite(b)) pairs.push(Math.abs(b - a));
  }
  if(pairs.length<6) return NaN;
  const lastAbs = pairs[pairs.length-1];
  const pct = percentileRank(lastAbs, pairs);
  return pct;
}

/*** ---------- Rendering ---------- ***/
let gaugeChart=null;

function bandFromScore(s){
  if(!Number.isFinite(s)) return {name:'—', color:'#6b7e92', badge:'', class:''};
  if(s<40) return {name:'Green', color: getComputedStyle(document.documentElement).getPropertyValue('--green').trim(), class:'green'};
  if(s<70) return {name:'Amber', color: getComputedStyle(document.documentElement).getPropertyValue('--amber').trim(), class:'amber'};
  return {name:'Red', color: getComputedStyle(document.documentElement).getPropertyValue('--red').trim(), class:'red'};
}

function renderGauge(score){
  const ctx = el('gauge').getContext('2d');
  const band = bandFromScore(score);
  const val = Number.isFinite(score)? Math.round(score) : 0;
  const rest = 100 - clamp(val,0,100);

  if(gaugeChart){ gaugeChart.destroy(); }
  gaugeChart = new Chart(ctx, {
    type:'doughnut',
    data:{ labels:['WBCI',''],
      datasets:[{
        data:[clamp(val,0,100), clamp(rest,0,100)],
        backgroundColor:[band.color,'#1f2a37'],
        borderWidth:0, circumference:270, rotation:225, cutout:'70%'
      }]
    },
    options:{
      responsive:false, animation:{duration:600},
      plugins:{ legend:{display:false}, tooltip:{enabled:false} }
    }
  });

  el('wbciVal').textContent = Number.isFinite(score)? Math.round(score).toString() : '—';
  el('wbciBand').textContent = band.name;
}

function setStatus(txt){ el('status').textContent = txt; }

function renderDiagnostics(diags){
  const wrap = el('diag');
  const ul = el('diagList');
  ul.innerHTML = '';
  if(!diags || !diags.length){ wrap.style.display='none'; return; }
  wrap.style.display='block';
  diags.forEach(msg=>{
    const li=document.createElement('li');
    li.textContent = msg;
    ul.appendChild(li);
  });
}

function chip(elm, label, value, bandClass=''){
  elm.textContent = `${label}: ${value}`;
  elm.classList.remove('bad','good');
  if(label==='Band'){
    if(value==='Red') elm.classList.add('bad');
    if(value==='Green') elm.classList.add('good');
  }
}

function makeSparkline(canvas, months, values, color){
  const ctx = canvas.getContext('2d');
  // last 12 months
  const L = Math.min(months.length, 12);
  const m = months.slice(-L);
  const v = values.slice(-L).map(x=>Number.isFinite(x)? x: null);
  const bd = getComputedStyle(document.documentElement).getPropertyValue('--chip').trim();
  return new Chart(ctx, {
    type:'line',
    data:{ labels:m, datasets:[{ data:v, tension:.25, borderColor:color, backgroundColor:color+'33', pointRadius:0, fill:true, borderWidth:2 }] },
    options:{
      maintainAspectRatio:false, scales:{ x:{display:false}, y:{display:false} },
      plugins:{ legend:{display:false}, tooltip:{mode:'index', intersect:false, callbacks:{
        title: items=> items[0]?.label || '',
        label: ctx=> ` ${Math.round(ctx.raw)}`
      }} }
    }
  });
}

function renderCards(categories){
  const container = el('cards');
  container.innerHTML = '';
  const palette = ['var(--cyan)','var(--blue)','var(--purple)','var(--amber)','var(--green)','var(--red)','var(--muted)'];
  for(let i=0;i<categories.length;i++){
    const c = categories[i];
    const cur = c.scores[c.scores.length-1];
    const band = bandFromScore(cur);
    const card = document.createElement('div');
    card.className = 'card catCard';
    const contextText = !Number.isFinite(cur)? 'Insufficient data'
      : (cur>=60? 'Pressuring' : (cur<=40? 'Cushioning' : 'Neutral'));

    card.innerHTML = `
      <div class="title">
        <div style="font-weight:700">${c.name}</div>
        <div class="badge ${band.class}">${Number.isFinite(cur)? Math.round(cur):'—'}</div>
      </div>
      <div class="sparkWrap"><canvas class="spark" aria-label="${c.name} sparkline"></canvas></div>
      <div class="meta">${c.baseline}</div>
      <div class="context"><strong>Context:</strong> ${contextText}</div>
    `;
    container.appendChild(card);
    const canvas = card.querySelector('canvas');
    makeSparkline(canvas, c.months, c.scores, getComputedStyle(document.documentElement).getPropertyValue(palette[i%palette.length].match(/--[a-z]+/)?palette[i%palette.length]:'--blue').trim() || '#52a7ff');
  }
}

function nowIsoMinute(){
  const d = new Date();
  const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), day=String(d.getDate()).padStart(2,'0');
  const hh=String(d.getHours()).padStart(2,'0'), mm=String(d.getMinutes()).padStart(2,'0');
  return `${y}-${m}-${day} ${hh}:${mm}`;
}

/*** ---------- Executive Summary ---------- ***/
function renderSummary(wbci, bandName, breadth, synch, shock, categories){
  const tops = categories.map(c=>({name:c.name, v:c.scores.at(-1)})).filter(x=>Number.isFinite(x.v))
                         .sort((a,b)=>b.v-a.v);
  const drivers = tops.filter(x=>x.v>=60).slice(0,2).map(x=>x.name);
  const cushions = categories.filter(c=>Number.isFinite(c.scores.at(-1)) && c.scores.at(-1)<=40)
                             .sort((a,b)=>a.scores.at(-1)-b.scores.at(-1)).slice(0,2).map(c=>c.name);
  const breadthTxt = Number.isFinite(breadth)? `${Math.round(breadth)}%` : '—';
  const synchTxt = Number.isFinite(synch)? `${Math.round(synch)}` : '—';
  const shockTxt = Number.isFinite(shock)? `${Math.round(shock)}` : '—';

  const oneLine = bandName==='Green' ? 'conditions are benign' :
                  bandName==='Amber' ? 'risk is building' : 'risk is elevated';

  const stance = bandName==='Red' ? 'Defensive, but ready to pivot if stress abates.' :
                 bandName==='Amber' ? 'Constructive but alert; lean quality and liquidity.' :
                 'Constructive, while watching late‑cycle telltales.';

  const triggers = 'Watch curve steepening, any sharp jump in HY OAS, and if jobless claims turn up persistently.';

  const text = [
    `Today’s WBCI reads ${Number.isFinite(wbci)?Math.round(wbci):'—'} (${bandName}), implying ${oneLine}.`,
    drivers.length? `Top pressures: ${drivers.join(' & ')}.` : 'No dominant pressure categories today.',
    cushions.length? `Cushioning: ${cushions.join(' & ')}.` : 'Few categories are cushioning risk at present.',
    `Breadth at ${breadthTxt} shows ${Number.isFinite(breadth) ? (breadth>=50?'broad':'narrow') : '—'} participation; synchronicity ${synchTxt}/100 suggests ${Number.isFinite(synch)? (synch>=60?'most categories are moving together':'mixed signals'):'—'}.`,
    shockTxt!=='—' ? `Shock gauge at ${shockTxt} (percentile of 1‑month change).` : 'Shock gauge unavailable (insufficient monthly history).',
    `${stance} ${triggers}`
  ].join(' ');
  el('summary').textContent = text;
}

/*** ---------- Main orchestration ---------- ***/
async function run(){
  const API = el('apiKey').value.trim();
  const banner = el('apiBanner');
  banner.style.display='none';
  banner.textContent='';

  if(!API || /YOUR_FRED_API_KEY_HERE/i.test(API)){
    banner.style.display='block';
    banner.textContent = 'Missing or placeholder API key. ' + DEFAULT_BANNER_GUIDE;
    setStatus('Blocked: API key required');
    renderDiagnostics(['API key missing/placeholder']);
    renderGauge(NaN);
    el('wbciBand').textContent='—'; el('wbciVal').textContent='—';
    el('ts').textContent='—';
    el('chips').querySelectorAll('.chip').forEach(c=>c.textContent=c.id.includes('Band')?'Band: —':c.textContent=c.textContent.split(':')[0]+': —');
    return;
  }

  // Start ISO: 11 years back to allow YoY transforms, but we’ll only score last 10 years
  const today = new Date();
  const start = new Date(Date.UTC(today.getUTCFullYear()-11, today.getUTCMonth(), 1));
  const startISO = `${start.getUTCFullYear()}-${String(start.getUTCMonth()+1).padStart(2,'0')}-01`;

  setStatus('Fetching…');
  el('runBtn').disabled = true; el('resetBtn').disabled = true;

  const { results, diagnostics } = await fetchAllSeries(API, startISO, (d)=>renderDiagnostics(d));
  // Possible invalid key hint: if zero series succeeded but got HTTP 400/403 style diag
  if(results.size===0){
    banner.style.display='block';
    const hint = diagnostics.some(x=>/FRED error|HTTP 400|HTTP 403|invalid/i.test(x)) ? ' (Your API key may be invalid or over quota.)' : '';
    banner.textContent = 'All series failed. ' + DEFAULT_BANNER_GUIDE + hint;
  }

  // Compute
  setStatus('Computing…');
  const { months, categories, composite } = computeCategoryAndComposite(results);

  // Choose the latest month where we have a composite
  let curIndex = composite.length-1;
  while(curIndex>=0 && !Number.isFinite(composite[curIndex])) curIndex--;
  const wbci = curIndex>=0 ? composite[curIndex] : NaN;
  const band = bandFromScore(wbci);
  renderGauge(wbci);
  el('ts').textContent = months.length? `As of ${months[curIndex]}` : '—';

  // Breadth
  const curCatScores = categories.map(c=>c.scores[curIndex]).filter(Number.isFinite);
  const breadth = curCatScores.length? 100*(curCatScores.filter(x=>x>=50).length / curCatScores.length) : NaN;

  // Synchronicity & Shock
  const synch = computeSynchronicity(categories, curIndex);
  const shock = computeShock(months, composite);

  // Chips
  chip(el('chipBand'), 'Band', band.name);
  chip(el('chipBreadth'), 'Breadth', Number.isFinite(breadth)? Math.round(breadth)+'%':'—');
  chip(el('chipSynch'), 'Synchronicity', Number.isFinite(synch)? Math.round(synch)+'/100':'—');
  chip(el('chipShock'), 'Shock', Number.isFinite(shock)? Math.round(shock):'—');

  // Executive summary
  renderSummary(wbci, band.name, breadth, synch, shock, categories);

  // Cards
  renderCards(categories);

  renderDiagnostics(diagnostics);
  setStatus(`Done • ${nowIsoMinute()}${results.size?` • ${results.size} series`:''}${diagnostics.length?` • ${diagnostics.length} issue(s)`:''}`);
  el('runBtn').disabled = false; el('resetBtn').disabled = false;
}

/*** ---------- Wire up UI ---------- ***/
el('runBtn').addEventListener('click', run);
el('resetBtn').addEventListener('click', ()=>{ resetCache(); setStatus('Cache cleared'); });

/*** ---------- Initial state ---------- ***/
renderGauge(NaN); // show empty gauge with placeholder
})();
</script>
</body>
</html>
